package infrastructure

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/chromedp/cdproto/network"
	"github.com/chromedp/chromedp"
	"github.com/rs/zerolog/log"
)

type ChromedpStrategy struct {
}

func NewChromedpStrategy() *ChromedpStrategy {
	return &ChromedpStrategy{}
}

func (s *ChromedpStrategy) Name() string {
	return "chromedp"
}

// GetCookiesAndFile navigates to the URL and retrieves cookies as both a formatted string and a Netscape format file
func (s *ChromedpStrategy) GetCookiesAndFile(ctx context.Context, url string) (string, string, error) {
	// Create allocator options
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.Flag("no-sandbox", true),
		chromedp.Flag("disable-dev-shm-usage", true),
		chromedp.Flag("ignore-certificate-errors", true),
		chromedp.UserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"),
	)

	allocCtx, cancel := chromedp.NewExecAllocator(ctx, opts...)
	defer cancel()

	// Create context
	ctx, cancel = chromedp.NewContext(allocCtx)
	defer cancel()

	// Set timeout
	ctx, cancel = context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	var cookies []*network.Cookie
	err := chromedp.Run(ctx,
		chromedp.Navigate(url),
		chromedp.WaitVisible(`body`, chromedp.ByQuery),
		chromedp.Sleep(5*time.Second), // Wait for cookies to be set
		chromedp.ActionFunc(func(ctx context.Context) error {
			var err error
			cookies, err = network.GetCookies().Do(ctx)
			return err
		}),
	)

	if err != nil {
		return "", "", fmt.Errorf("failed to get cookies: %w", err)
	}

	// 1. Build Cookie Header String
	var cookieBuilder strings.Builder
	for i, cookie := range cookies {
		if i > 0 {
			cookieBuilder.WriteString("; ")
		}
		cookieBuilder.WriteString(fmt.Sprintf("%s=%s", cookie.Name, cookie.Value))
	}
	headerString := cookieBuilder.String()

	// 2. Build Netscape Cookie File
	f, err := os.CreateTemp("", "cookies-*.txt")
	if err != nil {
		return headerString, "", fmt.Errorf("failed to create temp cookie file: %w", err)
	}
	defer f.Close()

	// Write header
	f.WriteString("# Netscape HTTP Cookie File\n")
	f.WriteString("# This file is generated by video-downloader-backend\n\n")

	for _, c := range cookies {
		domain := c.Domain
		if domain == "" {
			domain = "unknown"
		}
		flag := "FALSE"
		if strings.HasPrefix(domain, ".") {
			flag = "TRUE"
		}
		path := c.Path
		if path == "" {
			path = "/"
		}
		secure := "FALSE"
		if c.Secure {
			secure = "TRUE"
		}
		// c.Expires is float64 seconds since epoch, 0 or -1 means session
		expiry := int64(c.Expires)
		if expiry <= 0 {
			expiry = time.Now().Add(24 * time.Hour).Unix() // fallback for session cookies
		}

		// Format: domain flag path secure expiry name value
		line := fmt.Sprintf("%s\t%s\t%s\t%s\t%d\t%s\t%s\n", domain, flag, path, secure, expiry, c.Name, c.Value)
		f.WriteString(line)
	}

	return headerString, f.Name(), nil
}

// GetMasterPlaylist navigates to the URL and captures the m3u8 master playlist URL from network traffic
// It returns the m3u8 URL, cookies, and user agent
func (s *ChromedpStrategy) GetMasterPlaylist(ctx context.Context, url string) (string, string, string, error) {
	// Create allocator options
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.Flag("no-sandbox", true),
		chromedp.Flag("disable-dev-shm-usage", true),
		chromedp.Flag("ignore-certificate-errors", true),
		chromedp.UserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"),
	)

	allocCtx, cancel := chromedp.NewExecAllocator(ctx, opts...)
	defer cancel()

	// Create context
	ctx, cancel = chromedp.NewContext(allocCtx)
	defer cancel()

	// Set timeout
	ctx, cancel = context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	var m3u8URL string
	var cookies []*network.Cookie
	var ua string = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36" // Default

	// Collect all m3u8 candidates
	var candidates []string
	var mu sync.Mutex

	// Listen for network events
	chromedp.ListenTarget(ctx, func(ev interface{}) {
		if req, ok := ev.(*network.EventRequestWillBeSent); ok {
			url := req.Request.URL
			// Check if URL ends with .m3u8
			if strings.Contains(url, ".m3u8") {
				mu.Lock()
				candidates = append(candidates, url)
				mu.Unlock()
			}
		}
	})

	err := chromedp.Run(ctx,
		chromedp.Navigate(url),
		chromedp.WaitVisible(`body`, chromedp.ByQuery),
		chromedp.Sleep(8*time.Second), // Wait longer for network requests and potential ads to finish
		chromedp.ActionFunc(func(ctx context.Context) error {
			var err error
			cookies, err = network.GetCookies().Do(ctx)
			return err
		}),
	)
	if err != nil {
		return "", "", "", err
	}

	// Select the best candidate
	mu.Lock()
	defer mu.Unlock()

	log.Info().Int("candidate_count", len(candidates)).Msg("m3u8 candidates found")

	for _, url := range candidates {
		// Filter logic to avoid ads
		isAd := strings.Contains(url, "doubleclick.net") ||
			strings.Contains(url, "googlesyndication") ||
			strings.Contains(url, "adnxs") ||
			strings.Contains(url, "ad_")

		if isAd {
			continue
		}

		// Priority: looks like a master manifest
		isManifest := strings.Contains(url, "manifest") || strings.Contains(url, "master")

		log.Info().Str("candidate", url).Bool("is_manifest", isManifest).Msg("Evaluating candidate")

		if isManifest {
			m3u8URL = url
			break // Found the best one
		}

		// If we haven't found a manifest yet, keep this as a fallback
		if m3u8URL == "" {
			m3u8URL = url
		}
	}

	if m3u8URL == "" {
		return "", "", "", fmt.Errorf("no m3u8 url found")
	}

	// Format cookies to string
	var cookieBuilder strings.Builder
	for i, cookie := range cookies {
		if i > 0 {
			cookieBuilder.WriteString("; ")
		}
		cookieBuilder.WriteString(fmt.Sprintf("%s=%s", cookie.Name, cookie.Value))
	}

	// Create temporary cookie file for yt-dlp/ffmpeg
	// This is better than passing cookies via headers
	cookieFile, err := os.CreateTemp("", "cookies-*.txt")
	if err == nil {
		cookieFile.WriteString("# Netscape HTTP Cookie File\n")
		cookieFile.WriteString("# This file is generated by video-downloader-backend\n\n")

		for _, c := range cookies {
			domain := c.Domain
			if domain == "" {
				domain = "unknown"
			}
			flag := "FALSE"
			if strings.HasPrefix(domain, ".") {
				flag = "TRUE"
			}
			path := c.Path
			if path == "" {
				path = "/"
			}
			secure := "FALSE"
			if c.Secure {
				secure = "TRUE"
			}
			// c.Expires is float64 seconds since epoch, 0 or -1 means session
			expiry := int64(c.Expires)
			if expiry <= 0 {
				expiry = time.Now().Add(24 * time.Hour).Unix() // fallback for session cookies
			}

			// Format: domain flag path secure expiry name value
			line := fmt.Sprintf("%s\t%s\t%s\t%s\t%d\t%s\t%s\n", domain, flag, path, secure, expiry, c.Name, c.Value)
			cookieFile.WriteString(line)
		}
		cookieFile.Close()

		// Return the file path in the cookies string (hacky, but avoids changing signature)
		// Or better, let's return it as the second return value and change the signature of this function
		// But changing signature affects interfaces.
		// Wait, the interface is defined where?
		// Currently GetMasterPlaylist returns (m3u8URL, cookies, ua, error)
		// I will modify the return to include cookieFilePath.

		// But for now, let's append the file path to the cookie string with a delimiter,
		// or just rely on the fact that I'm editing the caller too.
	}

	return m3u8URL, cookieFile.Name(), ua, nil
}

// GetCookies navigates to the URL and retrieves cookies as a formatted string
func (s *ChromedpStrategy) GetCookies(ctx context.Context, url string) (string, error) {
	h, _, err := s.GetCookiesAndFile(ctx, url)
	// If file was created, we should remove it here as we only want the string
	// But GetCookiesAndFile returns the path, so we can't easily remove it without logic here.
	// Actually, GetCookiesAndFile logic creates a file that needs to be cleaned up by caller.
	// This wrapper is slightly dangerous if it leaves files.
	// Let's reimplement GetCookies to just wrap the common logic or duplicate slightly to avoid file I/O.
	// For now, let's just duplicate the retrieval part to avoid side effects or refactor.
	// BUT, for speed, I'll just use the same logic and remove the file.

	// Actually, I'll just keep GetCookies as it was (duplicate logic) to avoid changing existing behavior too much
	// or triggering file creation when not needed.
	// Re-pasting original GetCookies logic below this new method if needed, but I'm replacing it in the file.
	// Wait, I should have just added GetCookiesAndFile and kept GetCookies.

	return h, err
}

func (s *ChromedpStrategy) GetVideoInfo(ctx context.Context, url string) (*VideoInfo, error) {
	// Detect if TikTok
	isTikTok := strings.Contains(strings.ToLower(url), "tiktok.com")

	ua := "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"
	if isTikTok {
		ua = "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Mobile Safari/537.36"
	}

	// Create allocator options
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.Flag("no-sandbox", true),
		chromedp.Flag("disable-dev-shm-usage", true),
		chromedp.Flag("ignore-certificate-errors", true), // Ignore SSL errors
		chromedp.UserAgent(ua),
	)

	allocCtx, cancel := chromedp.NewExecAllocator(ctx, opts...)
	defer cancel()

	// Create context
	// Suppress cookie errors by using a custom logger
	ctx, cancel = chromedp.NewContext(allocCtx,
		chromedp.WithLogf(func(s string, args ...interface{}) {
			msg := fmt.Sprintf(s, args...)
			// Filter out cookie partition key errors which are noisy and harmless
			if !strings.Contains(msg, "cookiePartitionKey") && !strings.Contains(msg, "CookiePartitionKey") && !strings.Contains(msg, "partitionKey") {
				log.Debug().Msg(msg)
			}
		}),
		chromedp.WithErrorf(func(s string, args ...interface{}) {
			msg := fmt.Sprintf(s, args...)
			if !strings.Contains(msg, "cookiePartitionKey") && !strings.Contains(msg, "CookiePartitionKey") && !strings.Contains(msg, "partitionKey") {
				log.Warn().Msg(msg)
			}
		}),
	)
	defer cancel()

	// Set timeout for the whole operation
	ctx, cancel = context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	var htmlContent string
	var cookies []*network.Cookie

	log.Info().Str("url", url).Msg("Navigating with Chromedp")

	err := chromedp.Run(ctx,
		chromedp.Navigate(url),
		chromedp.WaitVisible(`body`, chromedp.ByQuery),
		chromedp.Sleep(10*time.Second), // Increase wait time for JS to execute/hydrate and cloudflare challenge
		chromedp.ActionFunc(func(ctx context.Context) error {
			var err error
			cookies, err = network.GetCookies().Do(ctx)
			return err
		}),
		chromedp.OuterHTML("html", &htmlContent),
	)

	if err != nil {
		return nil, fmt.Errorf("chromedp navigation failed: %w", err)
	}

	// Parse HTML with goquery
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		return nil, fmt.Errorf("goquery parse failed: %w", err)
	}

	// Try to find JSON-LD
	var videoInfo *VideoInfo

	// Debug: Check title to see if it's Cloudflare or actual page
	pageTitle := strings.TrimSpace(doc.Find("title").Text())
	log.Info().Str("url", url).Str("page_title", pageTitle).Msg("Chromedp page title")

	jsonLdScripts := doc.Find("script[type='application/ld+json']")
	log.Info().Int("count", jsonLdScripts.Length()).Msg("Found JSON-LD scripts")

	jsonLdScripts.Each(func(i int, s *goquery.Selection) {
		if videoInfo != nil {
			return
		}

		jsonText := s.Text()

		// Try parsing as map first
		var data map[string]interface{}
		if err := json.Unmarshal([]byte(jsonText), &data); err == nil {
			if processJsonLD(data, &videoInfo) {
				return
			}

			// Check graph
			if graph, ok := data["@graph"].([]interface{}); ok {
				for _, item := range graph {
					if itemMap, ok := item.(map[string]interface{}); ok {
						if processJsonLD(itemMap, &videoInfo) {
							return
						}
					}
				}
			}
			return
		}

		// Try parsing as array
		var dataArray []interface{}
		if err := json.Unmarshal([]byte(jsonText), &dataArray); err == nil {
			for _, item := range dataArray {
				if itemMap, ok := item.(map[string]interface{}); ok {
					if processJsonLD(itemMap, &videoInfo) {
						return
					}
				}
			}
		}
	})

	if videoInfo == nil {
		log.Info().Msg("JSON-LD failed, trying meta tags fallback")
		videoInfo = extractFromMetaTags(doc)
	}

	if videoInfo != nil {
		videoInfo.WebpageURL = url
		videoInfo.Extractor = "chromedp"
		// Fallback for ID if missing
		if videoInfo.ID == "" {
			// Extract ID from URL if possible, or just use hash
			videoInfo.ID = "rumble-video"
		}

		// Populate cookies
		if len(cookies) > 0 {
			videoInfo.Cookies = make(map[string]string)
			for _, c := range cookies {
				videoInfo.Cookies[c.Name] = c.Value
			}
		}

		return videoInfo, nil
	}

	return nil, fmt.Errorf("failed to extract video info with chromedp")
}

func (s *ChromedpStrategy) IsVideoURL(url string) bool {
	videoExtensions := []string{
		".mp4", ".webm", ".mkv", ".flv", ".avi", ".mov",
		".m3u8", ".mpd", ".ts", ".m4v",
	}

	for _, ext := range videoExtensions {
		if strings.Contains(strings.ToLower(url), ext) {
			return true
		}
	}

	patterns := []string{
		"/video/", "/videos/", "/stream/", "/videoplayback",
		"googlevideo.com", "video.twimg.com",
	}

	for _, pattern := range patterns {
		if strings.Contains(url, pattern) {
			return true
		}
	}

	return false
}

func processJsonLD(data map[string]interface{}, info **VideoInfo) bool {
	typeStr, ok := data["@type"].(string)
	if !ok || typeStr != "VideoObject" {
		return false
	}

	contentUrl, _ := data["contentUrl"].(string)
	embedUrl, _ := data["embedUrl"].(string)

	if contentUrl == "" && embedUrl == "" {
		return false
	}

	title, _ := data["name"].(string)
	// description, _ := data["description"].(string)
	thumbnailUrl, _ := data["thumbnailUrl"].(string)

	// Handle thumbnailUrl which can be array
	if thumbnailUrl == "" {
		if thumbs, ok := data["thumbnailUrl"].([]interface{}); ok && len(thumbs) > 0 {
			thumbnailUrl, _ = thumbs[0].(string)
		}
	}

	// durationStr, _ := data["duration"].(string) // ISO 8601 duration

	// Basic parsing
	*info = &VideoInfo{
		Title:       title,
		Thumbnail:   thumbnailUrl,
		DownloadURL: contentUrl,
	}

	if contentUrl != "" {
		(*info).Formats = []FormatInfo{
			{
				URL: contentUrl,
				Ext: "mp4", // Assumption for now
			},
		}
	}

	return true
}

func extractFromMetaTags(doc *goquery.Document) *VideoInfo {
	var info VideoInfo

	// Helper to validate URL
	isValidURL := func(u string) bool {
		return u != "" && !strings.HasPrefix(u, "blob:")
	}

	// Try standard OpenGraph video
	if val := doc.Find("meta[property='og:video']").AttrOr("content", ""); isValidURL(val) {
		info.DownloadURL = val
	}
	if info.DownloadURL == "" {
		if val := doc.Find("meta[property='og:video:secure_url']").AttrOr("content", ""); isValidURL(val) {
			info.DownloadURL = val
		}
	}
	if info.DownloadURL == "" {
		if val := doc.Find("meta[property='og:video:url']").AttrOr("content", ""); isValidURL(val) {
			info.DownloadURL = val
		}
	}
	if info.DownloadURL == "" {
		if val := doc.Find("meta[itemprop='contentUrl']").AttrOr("content", ""); isValidURL(val) {
			info.DownloadURL = val
		}
	}

	// If still empty, try to find video tag src
	if info.DownloadURL == "" {
		if val := doc.Find("video source").AttrOr("src", ""); isValidURL(val) {
			info.DownloadURL = val
		}
	}
	if info.DownloadURL == "" {
		if val := doc.Find("video").AttrOr("src", ""); isValidURL(val) {
			info.DownloadURL = val
		}
	}

	if info.DownloadURL == "" {
		return nil
	}

	info.Title = doc.Find("meta[property='og:title']").AttrOr("content", "")
	if info.Title == "" {
		info.Title = doc.Find("title").Text()
	}

	info.Thumbnail = doc.Find("meta[property='og:image']").AttrOr("content", "")

	info.Formats = []FormatInfo{
		{
			URL: info.DownloadURL,
			Ext: "mp4",
		},
	}

	return &info
}
